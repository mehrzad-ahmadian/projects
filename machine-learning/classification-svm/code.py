# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/147ZpMm65NOD-msJ1akYtVb-Ar138FRuQ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


# Read the data
df = pd.read_csv('data/data.csv')
df

# split data into train and test
from sklearn.model_selection import train_test_split

X = df.iloc[:, :-1]
y = df.iloc[:, -1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaler.fit(X_train)

X_train = scaler.transform(X_train)
X_test = scaler.transform(X_test)

# scale all data
X = scaler.transform(X)

# Train Classifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

res_train_df = pd.DataFrame(columns=['1', '100', '1000'], index=['RBF', 'Linear', 'Polynomial', 'Sigmoid'])
res_test_df = pd.DataFrame(columns=['1', '100', '1000'], index=['RBF', 'Linear', 'Polynomial', 'Sigmoid'])

"""## RBF Kernel"""

clf = SVC(C=1.0, kernel='rbf')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['RBF']['1'] = acc_train
res_test_df.loc['RBF']['1'] = acc_test

clf = SVC(C=100.0, kernel='rbf')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['RBF']['100'] = acc_train
res_test_df.loc['RBF']['100'] = acc_test

clf = SVC(C=1000.0, kernel='rbf')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['RBF']['1000'] = acc_train
res_test_df.loc['RBF']['1000'] = acc_test

"""## Linear Kernel"""

clf = SVC(C=1.0, kernel='linear')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Linear']['1'] = acc_train
res_test_df.loc['Linear']['1'] = acc_test

clf = SVC(C=100.0, kernel='linear')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Linear']['100'] = acc_train
res_test_df.loc['Linear']['100'] = acc_test

clf = SVC(C=1000.0, kernel='linear')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Linear']['1000'] = acc_train
res_test_df.loc['Linear']['1000'] = acc_test

"""## Polynomial Kernel"""

clf = SVC(C=1.0, kernel='poly')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Polynomial']['1'] = acc_train
res_test_df.loc['Polynomial']['1'] = acc_test

clf = SVC(C=100.0, kernel='poly')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Polynomial']['100'] = acc_train
res_test_df.loc['Polynomial']['100'] = acc_test

"""## Sigmoid Kernel"""

clf = SVC(C=1.0, kernel='sigmoid')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Sigmoid']['1'] = acc_train
res_test_df.loc['Sigmoid']['1'] = acc_test

clf = SVC(C=100.0, kernel='sigmoid')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc_train = accuracy_score(y_pred=y_train_pred, y_true=y_train)
acc_test = accuracy_score(y_pred=y_test_pred, y_true=y_test)

res_train_df.loc['Sigmoid']['100'] = acc_train
res_test_df.loc['Sigmoid']['100'] = acc_test

"""## Result"""

res_train_df

res_test_df

"""# Grid Search"""

from sklearn.model_selection import GridSearchCV

parameters = {'kernel': ('rbf',), 'C':[1, 10, 100, 500], 'gamma':[0.1, 0.3, 0.5, 0.7, 0.9]}

clf = GridSearchCV(SVC(), parameters)
clf.fit(X, y)

pd.DataFrame(clf.cv_results_).loc[:,['param_kernel', 'param_C', 'param_gamma', 'mean_test_score']]

parameters = {'kernel': ('linear', ), 'C':[1, 10, 100, 1000]}

clf = GridSearchCV(SVC(), parameters)
clf.fit(X, y)

pd.DataFrame(clf.cv_results_).loc[:,['param_kernel', 'param_C', 'mean_test_score']]

parameters = {'kernel': ('poly', ), 'degree':[2, 3, 4], 'C':[1, 10, 100, 500], 'gamma':[0.01, 0.03, 0.05]}

clf = GridSearchCV(SVC(), parameters)
clf.fit(X, y)

pd.DataFrame(clf.cv_results_).loc[:,['param_kernel', 'param_degree', 'param_C', 'param_gamma', 'mean_test_score']]

"""# Best Models"""

import itertools

# This function prints and plots the confusion matrix.
# Normalization can be applied by setting `normalize=True`.
def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    plt.figure(figsize = (5, 5))
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=0)
    plt.yticks(tick_marks, classes)
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]

    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j],
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

# best model of part b
clf = SVC(C=1000.0, kernel='rbf')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc = accuracy_score(y_pred=y_test_pred, y_true=y_test)
cm = confusion_matrix(y_pred=y_test_pred, y_true=y_test)

print('Accuracy: %.4f' % acc)
plot_confusion_matrix(cm, classes=y.unique())

# best model of part c
clf = SVC(C=10.0, gamma=0.3, kernel='rbf')
clf.fit(X_train, y_train)

y_train_pred = clf.predict(X_train)
y_test_pred = clf.predict(X_test)

acc = accuracy_score(y_pred=y_test_pred, y_true=y_test)
cm = confusion_matrix(y_pred=y_test_pred, y_true=y_test)

print('Accuracy: %.4f' % acc)
plot_confusion_matrix(cm, classes=y.unique())